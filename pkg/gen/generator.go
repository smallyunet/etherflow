package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
	"text/template"

	"github.com/ethereum/go-ethereum/accounts/abi"
)

// GenerateOptions configuration for code generation
type GenerateOptions struct {
	ABIPath     string
	PackageName string
	OutputPath  string
}

// Generate generates Go bindings from an ABI file
func Generate(opts GenerateOptions) error {
	// 1. Read ABI file
	f, err := os.Open(opts.ABIPath)
	if err != nil {
		return fmt.Errorf("failed to open ABI file: %w", err)
	}
	defer f.Close()

	// 2. Parse ABI
	parsedABI, err := abi.JSON(f)
	if err != nil {
		return fmt.Errorf("failed to parse ABI: %w", err)
	}

	// 3. Extract Events
	type EventInfo struct {
		Name      string
		TopicHash string // 0x...
		Fields    []struct {
			Name string
			Type string
		}
	}

	var events []EventInfo
	for name, event := range parsedABI.Events {
		// Calculate topic hash: keccak256(canonical_sig)
		// go-ethereum's event.ID is the hash
		topicHash := event.ID.Hex()

		e := EventInfo{
			Name:      name,
			TopicHash: topicHash,
		}

		for _, input := range event.Inputs {
			// Map solidity type to Go type (simplified)
			goType := mapType(input.Type.String())
			e.Fields = append(e.Fields, struct {
				Name string
				Type string
			}{
				Name: strings.Title(input.Name), // Public fields
				Type: goType,
			})
		}
		events = append(events, e)
	}

	// 4. Generate Code
	data := struct {
		PackageName string
		Events      []EventInfo
	}{
		PackageName: opts.PackageName,
		Events:      events,
	}

	tmpl := `// Code generated by etherflow gen. DO NOT EDIT.
package {{.PackageName}}

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/username/etherflow"
	"github.com/username/etherflow/pkg/core"
)

{{range .Events}}
// {{.Name}} event (Topic: {{.TopicHash}})
const Topic{{.Name}} = "{{.TopicHash}}"

type {{.Name}} struct {
{{range .Fields}}	{{.Name}} {{.Type}}
{{end}}}

// Register{{.Name}}Handler registers a handler for the {{.Name}} event
func Register{{.Name}}Handler(indexer *etherflow.Indexer, handler func(ctx *core.EventContext, event *{{.Name}}) error) {
	indexer.On(Topic{{.Name}}, func(ctx *core.EventContext) error {
		// TODO: Data decoding logic here
		// For now, we just pass context and empty struct
		// In real implementation, we would decode log.Data and log.Topics
		var e {{.Name}}
		return handler(ctx, &e)
	})
}
{{end}}
`

	t, err := template.New("bindings").Parse(tmpl)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	// 5. Format Code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format source: %w", err)
	}

	// 6. Write to file
	if err := os.WriteFile(opts.OutputPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	return nil
}

// mapType maps Solidity types to Go types
func mapType(solType string) string {
	// Simplified mapping
	if strings.Contains(solType, "int") {
		return "*big.Int" // import "math/big" needed
	}
	if solType == "address" {
		return "common.Address" // import "github.com/ethereum/go-ethereum/common" needed
	}
	if solType == "bool" {
		return "bool"
	}
	if solType == "string" {
		return "string"
	}
	// Fallback
	return "interface{}"
}
